"""
К перегружаемым операторам относятся: >, <, ≤, ≥, ==, !=, + =, -=.
При перегрузке каждого из них происходит вызов соответствующего метода, например:

__init__() — соответствует конструктору объектов класса, срабатывает при создании объектов;
__del__() — соответствует деструктору объектов класса, срабатывает при удалении объектов;
__str__() — срабатывает при передаче объекта функциям str() и print(), преобразует объект к строке;
__add__() — срабатывает при участии объекта в операции сложения в качестве операнда с левой стороны,
            обеспечивает перегрузку оператора сложения;
__setattr__() — срабатывает, когда выполняется операция присваивания значения атрибуту;
__getitem__() — срабатывает при извлечении элемента по индексу;
__call__() — срабатывает при обращении к экземпляру класса как к функции;
__gt__() — соответствует оператору >;
__lt__() — соответствует оператору <;
__ge__() — соответствует оператору ≥;
__le__() — соответствует оператору ≤;
__eq__() — соответствует оператору ==;
__iadd__() — соответствует операции «Сложение и присваивание» — +=;
__isub__() — соответствует операции «Вычитание и присваивание» — -=.

более полный список возможных перегрузок см. здесь https://pythonworld.ru/osnovy/peregruzka-operatorov.html
"""
class Bottle:
    def __init__(self, volume: float, warehouse: set):
        self.volume = volume
        self.empty = True
        self.warehouse = warehouse
        self.warehouse.add(self)
        print(f'Новый объект-бутылка с объёмом {self.volume} теперь в нашем распоряжении')

    def __del__(self):
        # print(f'Упс, бутылка разбилась')
        pass

    def trow_away(self):
        """Выкинуть бутылку"""
        self.warehouse.discard(self)
        print("Вы выкинули бутылку")

    def __str__(self):
        return f'Пузырь объемом {self.volume} ({"пустой" if self.empty else "полный"})'

    def __add__(self, other):
        volumes = self.volume + other.volume
        print(f'{self.volume}: Прикинув в уме сумму объёмов этих пузырей, получился литраж равный {volumes}')
        # перегрузка операторов обычно должна всегда отдавать новый объект этого же класса
        # return Bottle(volumes, self.warehouse)

    def __call__(self, count_sip: int):
        print(f'{count_sip} - именно такое кол-во глотков Вам хотелось бы сделать из этого пузыря')




